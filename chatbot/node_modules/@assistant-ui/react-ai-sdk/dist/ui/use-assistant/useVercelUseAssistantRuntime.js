"use client";

// src/ui/use-assistant/useVercelUseAssistantRuntime.tsx
import { useExternalStoreRuntime } from "@assistant-ui/react";
import { useInputSync } from "../utils/useInputSync.js";
import { toCreateMessage } from "../utils/toCreateMessage.js";
import { vercelAttachmentAdapter } from "../utils/vercelAttachmentAdapter.js";
import { AISDKMessageConverter } from "../utils/convertMessage.js";
var useVercelUseAssistantRuntime = (assistantHelpers, adapter = {}) => {
  const messages = AISDKMessageConverter.useThreadMessages({
    messages: assistantHelpers.messages,
    isRunning: assistantHelpers.status === "in_progress"
  });
  const runtime = useExternalStoreRuntime({
    isRunning: assistantHelpers.status === "in_progress",
    messages,
    onCancel: async () => assistantHelpers.stop(),
    onNew: async (message) => {
      await assistantHelpers.append(await toCreateMessage(message));
    },
    adapters: {
      attachments: vercelAttachmentAdapter,
      ...adapter.adapters,
      threadList: new Proxy(adapter.adapters?.threadList ?? {}, {
        get(target, prop, receiver) {
          if (prop === "onSwitchToNewThread") {
            return () => {
              assistantHelpers.messages = [];
              assistantHelpers.input = "";
              assistantHelpers.setMessages([]);
              assistantHelpers.setInput("");
              if (typeof target.onSwitchToNewThread === "function") {
                return target.onSwitchToNewThread.call(target);
              }
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      })
    }
  });
  useInputSync(assistantHelpers, runtime);
  return runtime;
};
export {
  useVercelUseAssistantRuntime
};
//# sourceMappingURL=useVercelUseAssistantRuntime.js.map