"use client";

// src/ui/use-chat/useVercelUseChatRuntime.tsx
import { useExternalStoreRuntime } from "@assistant-ui/react";
import { useInputSync } from "../utils/useInputSync.js";
import { sliceMessagesUntil } from "../utils/sliceMessagesUntil.js";
import { toCreateMessage } from "../utils/toCreateMessage.js";
import { vercelAttachmentAdapter } from "../utils/vercelAttachmentAdapter.js";
import { getVercelAIMessages } from "../getVercelAIMessages.js";
import { useState } from "react";
import { generateId } from "@ai-sdk/ui-utils";
import { AISDKMessageConverter } from "../utils/convertMessage.js";
var useVercelUseChatRuntime = (chatHelpers, adapter = {}) => {
  const messages = AISDKMessageConverter.useThreadMessages({
    isRunning: chatHelpers.status === "submitted" || chatHelpers.status == "streaming",
    messages: chatHelpers.messages,
    joinStrategy: adapter.unstable_joinStrategy
  });
  const [threadId, setThreadId] = useState(generateId());
  const runtime = useExternalStoreRuntime({
    isRunning: chatHelpers.isLoading,
    messages,
    setMessages: (messages2) => chatHelpers.setMessages(messages2.map(getVercelAIMessages).flat()),
    onCancel: async () => chatHelpers.stop(),
    onNew: async (message) => {
      await chatHelpers.append(await toCreateMessage(message));
    },
    onEdit: async (message) => {
      const newMessages = sliceMessagesUntil(
        chatHelpers.messages,
        message.parentId
      );
      chatHelpers.setMessages(newMessages);
      await chatHelpers.append(await toCreateMessage(message));
    },
    onReload: async (parentId) => {
      const newMessages = sliceMessagesUntil(chatHelpers.messages, parentId);
      chatHelpers.setMessages(newMessages);
      await chatHelpers.reload();
    },
    onAddToolResult: ({ toolCallId, result }) => {
      chatHelpers.addToolResult({ toolCallId, result });
    },
    adapters: {
      attachments: vercelAttachmentAdapter,
      ...adapter.adapters,
      threadList: new Proxy(adapter.adapters?.threadList ?? {}, {
        get(target, prop, receiver) {
          if (prop === "threadId") {
            return target.threadId ?? threadId;
          }
          if (prop === "onSwitchToNewThread") {
            return () => {
              chatHelpers.messages = [];
              chatHelpers.input = "";
              chatHelpers.setMessages([]);
              chatHelpers.setInput("");
              setThreadId(generateId());
              if (typeof target.onSwitchToNewThread === "function") {
                return target.onSwitchToNewThread.call(target);
              }
            };
          }
          return Reflect.get(target, prop, receiver);
        }
      })
    }
  });
  useInputSync(chatHelpers, runtime);
  return runtime;
};
export {
  useVercelUseChatRuntime
};
//# sourceMappingURL=useVercelUseChatRuntime.js.map