{"version":3,"sources":["../../src/ai-sdk/index.ts"],"sourcesContent":["import type { TextStreamPart, ObjectStreamPart, Tool } from \"ai\";\nimport { AssistantStream } from \"../core/AssistantStream\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\nimport { ReadonlyJSONValue } from \"../utils/json/json-value\";\n\nexport const fromStreamText = (\n  stream: ReadableStream<TextStreamPart<Record<string, Tool>>>,\n): AssistantStream => {\n  const toolControllers = new Map<string, ToolCallStreamController>();\n  let currentToolCallArgsText: ToolCallStreamController | undefined;\n\n  const endCurrentToolCallArgsText = () => {\n    if (!currentToolCallArgsText) return;\n    currentToolCallArgsText.argsText.close();\n    currentToolCallArgsText = undefined;\n  };\n\n  const transformer = new AssistantTransformStream<\n    TextStreamPart<Record<string, Tool>>\n  >({\n    transform(chunk, controller) {\n      const { type } = chunk;\n\n      if (\n        type !== \"tool-call-delta\" &&\n        type !== \"tool-call\" &&\n        type !== \"error\" &&\n        (type as string) !== \"tool-result\"\n      ) {\n        endCurrentToolCallArgsText();\n      }\n\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          controller.appendText(textDelta);\n          break;\n        }\n        case \"reasoning\": {\n          const { textDelta } = chunk;\n          controller.appendReasoning(textDelta);\n          break;\n        }\n        case \"tool-call-streaming-start\": {\n          const { toolCallId, toolName } = chunk;\n          currentToolCallArgsText = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolControllers.set(toolCallId, currentToolCallArgsText);\n          break;\n        }\n        case \"tool-call-delta\": {\n          const { toolCallId, argsTextDelta } = chunk;\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.argsText.append(argsTextDelta);\n          break;\n        }\n        case \"tool-result\" as string: {\n          const { toolCallId, result } = chunk as unknown as {\n            toolCallId: string;\n            result: ReadonlyJSONValue;\n          };\n          const toolController = toolControllers.get(toolCallId);\n          if (!toolController) throw new Error(\"Tool call not found\");\n          toolController.setResponse({\n            result,\n          });\n          toolController.close();\n          toolControllers.delete(toolCallId);\n          break;\n        }\n        case \"tool-call\": {\n          const { toolCallId, toolName, args } = chunk;\n          const toolController = controller.addToolCallPart({\n            toolCallId,\n            toolName,\n          });\n          toolController.argsText.append(JSON.stringify(args));\n          toolController.argsText.close();\n          toolControllers.set(toolCallId, toolController);\n          break;\n        }\n\n        case \"step-start\":\n          controller.enqueue({\n            type: \"step-start\",\n            path: [],\n            messageId: chunk.messageId,\n          });\n          break;\n        case \"step-finish\":\n          controller.enqueue({\n            type: \"step-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n            isContinued: chunk.isContinued,\n          });\n          break;\n        case \"error\":\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n\n        case \"finish\": {\n          controller.enqueue({\n            type: \"message-finish\",\n            path: [],\n            finishReason: chunk.finishReason,\n            usage: chunk.usage,\n          });\n          break;\n        }\n\n        case \"source\":\n          controller.appendSource({\n            type: \"source\",\n            ...chunk.source,\n          });\n          break;\n\n        case \"file\":\n          controller.appendFile({\n            type: \"file\",\n            mimeType: chunk.mimeType,\n            data: chunk.base64,\n          });\n          break;\n\n        case \"reasoning-signature\":\n        case \"redacted-reasoning\":\n          // ignore these for now\n          break;\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n    flush() {\n      for (const toolController of toolControllers.values()) {\n        toolController.close();\n      }\n      toolControllers.clear();\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n\nexport const fromStreamObject = (\n  stream: ReadableStream<ObjectStreamPart<unknown>>,\n  toolName: string,\n): AssistantStream => {\n  let toolCall!: ToolCallStreamController;\n  const transformer = new AssistantTransformStream<ObjectStreamPart<unknown>>({\n    start(controller) {\n      toolCall = controller.addToolCallPart(toolName);\n    },\n    transform(chunk, controller) {\n      const { type } = chunk;\n      switch (type) {\n        case \"text-delta\": {\n          const { textDelta } = chunk;\n          toolCall.argsText.append(textDelta);\n          break;\n        }\n        case \"finish\": {\n          toolCall.argsText.close();\n          toolCall.setResponse({\n            result: \"{}\",\n          });\n          break;\n        }\n\n        case \"object\":\n          break;\n\n        case \"error\": {\n          controller.enqueue({\n            type: \"error\",\n            path: [],\n            error: String(chunk.error),\n          });\n          break;\n        }\n\n        default: {\n          const unhandledType: never = type;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n  });\n\n  return stream.pipeThrough(transformer);\n};\n"],"mappings":"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","names":[]}