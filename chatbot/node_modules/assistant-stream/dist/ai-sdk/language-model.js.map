{"version":3,"sources":["../../src/ai-sdk/language-model.ts"],"sourcesContent":["import type { LanguageModelV1StreamPart } from \"ai\";\nimport { AssistantTransformStream } from \"../core/utils/stream/AssistantTransformStream\";\nimport { ToolCallStreamController } from \"../core/modules/tool-call\";\n\nfunction bufferToBase64(buffer: Uint8Array) {\n  return btoa(String.fromCharCode(...buffer));\n}\n\nexport class LanguageModelV1StreamDecoder extends AssistantTransformStream<LanguageModelV1StreamPart> {\n  constructor() {\n    let currentToolCall:\n      | { toolCallId: string; controller: ToolCallStreamController }\n      | undefined;\n\n    const endCurrentToolCall = () => {\n      if (!currentToolCall) return;\n      currentToolCall.controller.argsText.close();\n      currentToolCall.controller.close();\n      currentToolCall = undefined;\n    };\n\n    super({\n      transform(chunk, controller) {\n        const { type } = chunk;\n        if (type === \"text-delta\" || type === \"reasoning\") {\n          endCurrentToolCall();\n        }\n\n        switch (type) {\n          case \"text-delta\": {\n            controller.appendText(chunk.textDelta);\n            break;\n          }\n          case \"reasoning\": {\n            controller.appendReasoning(chunk.textDelta);\n            break;\n          }\n\n          case \"source\": {\n            controller.appendSource({\n              type: \"source\",\n              ...chunk.source,\n            });\n            break;\n          }\n\n          case \"file\": {\n            controller.appendFile({\n              type: \"file\",\n              mimeType: chunk.mimeType,\n              data:\n                typeof chunk.data === \"string\"\n                  ? chunk.data\n                  : bufferToBase64(chunk.data),\n            });\n            break;\n          }\n\n          case \"tool-call-delta\": {\n            const { toolCallId, toolName, argsTextDelta } = chunk;\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            } else {\n              endCurrentToolCall();\n              currentToolCall = {\n                toolCallId,\n                controller: controller.addToolCallPart({\n                  toolCallId,\n                  toolName,\n                }),\n              };\n              currentToolCall.controller.argsText.append(argsTextDelta);\n            }\n\n            break;\n          }\n\n          case \"tool-call\": {\n            const { toolCallId, toolName, args } = chunk;\n\n            if (currentToolCall?.toolCallId === toolCallId) {\n              currentToolCall.controller.argsText.close();\n            } else {\n              const toolController = controller.addToolCallPart({\n                toolCallId,\n                toolName,\n                argsText: args,\n              });\n              toolController.close();\n            }\n\n            break;\n          }\n          case \"finish\": {\n            controller.enqueue({\n              type: \"message-finish\",\n              finishReason: chunk.finishReason,\n              usage: chunk.usage,\n              path: [],\n            });\n            controller.close();\n            break;\n          }\n\n          case \"error\":\n          case \"response-metadata\":\n          case \"reasoning-signature\":\n          case \"redacted-reasoning\":\n            break;\n\n          default: {\n            const unhandledType: never = type;\n            throw new Error(`Unhandled chunk type: ${unhandledType}`);\n          }\n        }\n      },\n      flush() {\n        endCurrentToolCall();\n      },\n    });\n  }\n}\n"],"mappings":";AACA,SAAS,gCAAgC;AAGzC,SAAS,eAAe,QAAoB;AAC1C,SAAO,KAAK,OAAO,aAAa,GAAG,MAAM,CAAC;AAC5C;AAEO,IAAM,+BAAN,cAA2C,yBAAoD;AAAA,EACpG,cAAc;AACZ,QAAI;AAIJ,UAAM,qBAAqB,MAAM;AAC/B,UAAI,CAAC,gBAAiB;AACtB,sBAAgB,WAAW,SAAS,MAAM;AAC1C,sBAAgB,WAAW,MAAM;AACjC,wBAAkB;AAAA,IACpB;AAEA,UAAM;AAAA,MACJ,UAAU,OAAO,YAAY;AAC3B,cAAM,EAAE,KAAK,IAAI;AACjB,YAAI,SAAS,gBAAgB,SAAS,aAAa;AACjD,6BAAmB;AAAA,QACrB;AAEA,gBAAQ,MAAM;AAAA,UACZ,KAAK,cAAc;AACjB,uBAAW,WAAW,MAAM,SAAS;AACrC;AAAA,UACF;AAAA,UACA,KAAK,aAAa;AAChB,uBAAW,gBAAgB,MAAM,SAAS;AAC1C;AAAA,UACF;AAAA,UAEA,KAAK,UAAU;AACb,uBAAW,aAAa;AAAA,cACtB,MAAM;AAAA,cACN,GAAG,MAAM;AAAA,YACX,CAAC;AACD;AAAA,UACF;AAAA,UAEA,KAAK,QAAQ;AACX,uBAAW,WAAW;AAAA,cACpB,MAAM;AAAA,cACN,UAAU,MAAM;AAAA,cAChB,MACE,OAAO,MAAM,SAAS,WAClB,MAAM,OACN,eAAe,MAAM,IAAI;AAAA,YACjC,CAAC;AACD;AAAA,UACF;AAAA,UAEA,KAAK,mBAAmB;AACtB,kBAAM,EAAE,YAAY,UAAU,cAAc,IAAI;AAChD,gBAAI,iBAAiB,eAAe,YAAY;AAC9C,8BAAgB,WAAW,SAAS,OAAO,aAAa;AAAA,YAC1D,OAAO;AACL,iCAAmB;AACnB,gCAAkB;AAAA,gBAChB;AAAA,gBACA,YAAY,WAAW,gBAAgB;AAAA,kBACrC;AAAA,kBACA;AAAA,gBACF,CAAC;AAAA,cACH;AACA,8BAAgB,WAAW,SAAS,OAAO,aAAa;AAAA,YAC1D;AAEA;AAAA,UACF;AAAA,UAEA,KAAK,aAAa;AAChB,kBAAM,EAAE,YAAY,UAAU,KAAK,IAAI;AAEvC,gBAAI,iBAAiB,eAAe,YAAY;AAC9C,8BAAgB,WAAW,SAAS,MAAM;AAAA,YAC5C,OAAO;AACL,oBAAM,iBAAiB,WAAW,gBAAgB;AAAA,gBAChD;AAAA,gBACA;AAAA,gBACA,UAAU;AAAA,cACZ,CAAC;AACD,6BAAe,MAAM;AAAA,YACvB;AAEA;AAAA,UACF;AAAA,UACA,KAAK,UAAU;AACb,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN,cAAc,MAAM;AAAA,cACpB,OAAO,MAAM;AAAA,cACb,MAAM,CAAC;AAAA,YACT,CAAC;AACD,uBAAW,MAAM;AACjB;AAAA,UACF;AAAA,UAEA,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH;AAAA,UAEF,SAAS;AACP,kBAAM,gBAAuB;AAC7B,kBAAM,IAAI,MAAM,yBAAyB,aAAa,EAAE;AAAA,UAC1D;AAAA,QACF;AAAA,MACF;AAAA,MACA,QAAQ;AACN,2BAAmB;AAAA,MACrB;AAAA,IACF,CAAC;AAAA,EACH;AACF;","names":[]}