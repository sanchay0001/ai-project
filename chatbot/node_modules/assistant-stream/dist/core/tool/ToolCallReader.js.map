{"version":3,"sources":["../../../src/core/tool/ToolCallReader.ts"],"sourcesContent":["import { promiseWithResolvers } from \"../../utils/promiseWithResolvers\";\nimport {\n  parsePartialJsonObject,\n  getPartialJsonObjectFieldState,\n} from \"../../utils/json/parse-partial-json-object\";\nimport {\n  ToolCallArgsReader,\n  ToolCallReader,\n  ToolCallResponseReader,\n} from \"./tool-types\";\nimport { TypeAtPath, TypePath } from \"./type-path-utils\";\nimport { ToolResponse } from \"./ToolResponse\";\n\n// TODO: remove dispose\n\nfunction getField<T>(obj: T, fieldPath: (string | number)[]): any {\n  let current: any = obj;\n  for (const key of fieldPath) {\n    if (current === undefined || current === null) {\n      return undefined;\n    }\n    current = current[key as string | number];\n  }\n  return current;\n}\n\ninterface Handle {\n  update(args: unknown): void;\n  dispose(): void;\n}\n\nclass GetHandle<T> implements Handle {\n  private resolve: (value: any) => void;\n  private reject: (reason: unknown) => void;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n\n  constructor(\n    resolve: (value: any) => void,\n    reject: (reason: unknown) => void,\n    fieldPath: (string | number)[],\n  ) {\n    this.resolve = resolve;\n    this.reject = reject;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      // Check if the field is complete\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        const value = getField(args as T, this.fieldPath);\n        if (value !== undefined) {\n          this.resolve(value);\n          this.dispose();\n        }\n      }\n    } catch (e) {\n      this.reject(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass StreamValuesHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<any>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n\n  constructor(\n    controller: ReadableStreamDefaultController<any>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const value = getField(args as T, this.fieldPath);\n\n      if (value !== undefined) {\n        this.controller.enqueue(value);\n      }\n\n      // Check if the field is complete, if so close the stream\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass StreamTextHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<any>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n  private lastValue: any = undefined;\n\n  constructor(\n    controller: ReadableStreamDefaultController<any>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const value = getField(args as T, this.fieldPath);\n\n      if (value !== undefined && typeof value === \"string\") {\n        const delta = value.substring(this.lastValue?.length || 0);\n        this.lastValue = value;\n        this.controller.enqueue(delta);\n      }\n\n      // Check if the field is complete, if so close the stream\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\nclass ForEachHandle<T> implements Handle {\n  private controller: ReadableStreamDefaultController<any>;\n  private disposed = false;\n  private fieldPath: (string | number)[];\n  private processedIndexes = new Set<number>();\n\n  constructor(\n    controller: ReadableStreamDefaultController<any>,\n    fieldPath: (string | number)[],\n  ) {\n    this.controller = controller;\n    this.fieldPath = fieldPath;\n  }\n\n  update(args: unknown): void {\n    if (this.disposed) return;\n\n    try {\n      const array = getField(args as T, this.fieldPath) as unknown as any[];\n\n      if (!Array.isArray(array)) {\n        return;\n      }\n\n      // Check each array element and emit completed ones that haven't been processed\n      for (let i = 0; i < array.length; i++) {\n        if (!this.processedIndexes.has(i)) {\n          const elementPath = [...this.fieldPath, i];\n          if (\n            getPartialJsonObjectFieldState(\n              args as Record<string, unknown>,\n              elementPath,\n            ) === \"complete\"\n          ) {\n            this.controller.enqueue(array[i]);\n            this.processedIndexes.add(i);\n          }\n        }\n      }\n\n      // Check if the entire array is complete\n      if (\n        getPartialJsonObjectFieldState(\n          args as Record<string, unknown>,\n          this.fieldPath,\n        ) === \"complete\"\n      ) {\n        this.controller.close();\n        this.dispose();\n      }\n    } catch (e) {\n      this.controller.error(e);\n      this.dispose();\n    }\n  }\n\n  dispose(): void {\n    this.disposed = true;\n  }\n}\n\n// Implementation of ToolCallReader that uses stream of partial JSON\nexport class ToolCallArgsReaderImpl<T> implements ToolCallArgsReader<T> {\n  private argTextDeltas: ReadableStream<string>;\n  private handles: Set<Handle> = new Set();\n  private args: any = parsePartialJsonObject(\"\");\n\n  constructor(argTextDeltas: ReadableStream<string>) {\n    this.argTextDeltas = argTextDeltas;\n    this.processStream();\n  }\n\n  private async processStream(): Promise<void> {\n    try {\n      let accumulatedText = \"\";\n      const reader = this.argTextDeltas.getReader();\n\n      while (true) {\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        accumulatedText += value;\n        const parsedArgs = parsePartialJsonObject(accumulatedText);\n\n        if (parsedArgs !== undefined) {\n          this.args = parsedArgs;\n          // Notify all handles of the updated args\n          for (const handle of this.handles) {\n            handle.update(parsedArgs);\n          }\n        }\n      }\n    } catch (error) {\n      console.error(\"Error processing argument stream:\", error);\n      // Notify handles of the error\n      for (const handle of this.handles) {\n        handle.dispose();\n      }\n    }\n  }\n\n  get<PathT extends TypePath<T>>(\n    ...fieldPath: PathT\n  ): Promise<TypeAtPath<T, PathT>> {\n    return new Promise<any>((resolve, reject) => {\n      const handle = new GetHandle<T>(resolve, reject, fieldPath);\n\n      // Check if the field is already complete in current args\n      if (\n        this.args &&\n        getPartialJsonObjectFieldState(\n          this.args as Record<string, unknown>,\n          fieldPath,\n        ) === \"complete\"\n      ) {\n        const value = getField(this.args as T, fieldPath);\n        if (value !== undefined) {\n          resolve(value);\n          return;\n        }\n      }\n\n      this.handles.add(handle);\n      handle.update(this.args);\n    });\n  }\n\n  streamValues<PathT extends TypePath<T>>(...fieldPath: PathT): any {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<any>({\n      start: (controller) => {\n        const handle = new StreamValuesHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof StreamValuesHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    // For type compatibility, cast the stream to the required type\n    return stream as any;\n  }\n\n  streamText<PathT extends TypePath<T>>(...fieldPath: PathT): any {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<any>({\n      start: (controller) => {\n        const handle = new StreamTextHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof StreamTextHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    // For type compatibility, cast the stream to the required type\n    return stream as any;\n  }\n\n  forEach<PathT extends TypePath<T>>(...fieldPath: PathT): any {\n    // Use a type assertion to convert the complex TypePath to a simple array\n    const simplePath = fieldPath as unknown as (string | number)[];\n\n    const stream = new ReadableStream<any>({\n      start: (controller) => {\n        const handle = new ForEachHandle<T>(controller, simplePath);\n        this.handles.add(handle);\n\n        // Check current args immediately\n        handle.update(this.args);\n      },\n      cancel: () => {\n        // Find and dispose the corresponding handle\n        for (const handle of this.handles) {\n          if (handle instanceof ForEachHandle) {\n            handle.dispose();\n            this.handles.delete(handle);\n            break;\n          }\n        }\n      },\n    });\n\n    // For type compatibility, cast the stream to the required type\n    return stream as any;\n  }\n}\n\nexport class ToolCallResponseReaderImpl<TResult>\n  implements ToolCallResponseReader<TResult>\n{\n  constructor(private readonly promise: Promise<ToolResponse<TResult>>) {}\n\n  public get() {\n    return this.promise;\n  }\n}\n\nexport class ToolCallReaderImpl<TArgs, TResult>\n  implements ToolCallReader<TArgs, TResult>\n{\n  public readonly args: ToolCallArgsReaderImpl<TArgs>;\n  public readonly response: ToolCallResponseReaderImpl<TResult>;\n  private readonly writable: WritableStream<string>;\n  private readonly resolve: (value: ToolResponse<TResult>) => void;\n\n  public argsText: string = \"\";\n\n  constructor() {\n    const stream = new TransformStream<string, string>();\n    this.writable = stream.writable;\n    this.args = new ToolCallArgsReaderImpl<TArgs>(stream.readable);\n\n    const { promise, resolve } = promiseWithResolvers<ToolResponse<TResult>>();\n    this.resolve = resolve;\n    this.response = new ToolCallResponseReaderImpl<TResult>(promise);\n  }\n\n  async appendArgsTextDelta(text: string): Promise<void> {\n    const writer = this.writable.getWriter();\n    try {\n      await writer.write(text);\n    } catch (err) {\n      console.warn(err);\n    } finally {\n      writer.releaseLock();\n    }\n\n    this.argsText += text;\n  }\n\n  setResponse(value: ToolResponse<TResult>): void {\n    this.resolve(value);\n  }\n\n  result = {\n    get: async () => {\n      const response = await this.response.get();\n      return response.result;\n    },\n  };\n}\n"],"mappings":"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","names":[]}